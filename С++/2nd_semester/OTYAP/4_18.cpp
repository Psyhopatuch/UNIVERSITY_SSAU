#include <iostream> // Подключим библиотеку для работы с потоками ввода-вывода
#include <fstream>  // Подключим библиотеку для работы с файловыми потоками
#include <vector>   // Подключим библиотеку для работы с std::vector
#include <cstring>  // Подключим библиотеку для работы с С-строками

using namespace std;

// Объявляем перечисление с именем LEX_STATES
enum LEX_STATES
{
    A, // Состояние чтения идентификатора
    B, // Состояние чтения константы
    C, // Состояние чтения арифметических символов
    D, // Состояние чтения знака ';'
    E, // Состояние чтения неизвестной лексемы и прочие ошибки
    K, // Состояние чтения знака '='
    H, // Состояние чтения знака '>'
    I, // Состояние чтения знака '<>'
    J, // Состояние чтения знака '<'
    F, // Состояние выхода из автомата
    S  // Начальное состояние
};

// Удобно будет хранить массив типов лексем, индексы типов совпадают с состояниями
const char *types[] = {"id\0", "vl\0", "ao\0", "sc\0", "wl\0", "eq\0", "co\0", "do\0", "un\0", "lp\0", "lo\0", "no\0"};

// Матрица состояний и переходов конечного автомата
const enum LEX_STATES LEX_ST_MATRIX[10][11]{
    //       A  B  C  D  E  K  H  I  J  F  S
    /*A-z*/ {A, E, A, A, E, A, A, A, A, F, A},
    /*0-9*/ {A, B, B, B, E, B, B, B, B, F, B},
    /*Sep*/ {S, S, S, S, S, S, S, S, S, F, S},
    /*Ari*/ {C, C, C, C, E, C, C, C, C, F, C},
    /* ; */ {D, D, D, D, D, D, D, D, D, F, D},
    /* < */ {J, J, J, J, J, J, J, J, J, F, J},
    /* = */ {K, K, K, K, K, K, K, K, K, F, K},
    /* > */ {H, H, H, H, H, H, H, H, I, F, I},
    /* \0*/ {F, F, F, F, F, F, F, F, F, F, F},
    /*NAS*/ {E, E, E, E, E, E, E, E, E, F, E}};

// Функция для перехода по матрице состояний автомата, возвращает индекс символа в матрице автомата
int GetNextState(const char temp)
{

    if (isalpha(temp))
        return 0; /*A-z*/
    if ((int)temp > 47 && temp < 58)
        return 1; /*0-9*/

    switch (temp)
    {
    case (' '): /*Sep*/
        return 2;
        break;
    case ('\n'): /*Sep*/
        return 2;
        break;
    case ('\t'): /*Sep*/
        return 2;
        break;
    case ('*'): /*Ari*/
        return 3;
        break;
    case ('+'): /*Ari*/
        return 3;
        break;
    case ('-'): /*Ari*/
        return 3;
        break;
    case ('/'): /*Ari*/
        return 3;
        break;
    case (';'): /* ; */
        return 4;
        break;
    case ('<'): /* < */
        return 5;
        break;
    case ('='): /* = */
        return 6;
        break;
    case ('>'): /* > */
        return 7;
        break;
    case ('\0'): /* \0*/
        return 8;
        break;
    }

    return 9; /*NAS*/
}

struct Lex
{
    char *str = nullptr; // Текст лексемы
    int id = 4;          // id типа лексемы
};

// Функция, сравнивающая лексему с ключевыми словами
// Устанавливает ID для ключевых слов
bool set_kw_id(Lex &lex)
{ // strcmp вернёт ноль, если С-строки равны
    if (!strcmp(lex.str, "do"))
    {
        lex.id = 7;
        return true; // Вернём истину, если идентификатор это ключевое слово
    }
    if (!strcmp(lex.str, "until"))
    {
        lex.id = 8;
        return true; // Вернём истину, если идентификатор это ключевое слово
    }
    if (!strcmp(lex.str, "loop"))
    {
        lex.id = 9;
        return true; // Вернём истину, если идентификатор это ключевое слово
    }
    if (!strcmp(lex.str, "and"))
    {
        lex.id = 10;
        return true; // Вернём истину, если идентификатор это ключевое слово
    }
    if (!strcmp(lex.str, "or"))
    {
        lex.id = 10;
        return true; // Вернём истину, если идентификатор это ключевое слово
    }
    if (!strcmp(lex.str, "not"))
    {
        lex.id = 11;
        return true; // Вернём истину, если идентификатор это ключевое слово
    }
    return false; // Вернём ложь, если идентификатор не ключевое слово
}

void lex_analizer(char *text, vector<Lex> &vec)
{
    LEX_STATES cur_state = S; // Объявим и инициализируем переменную, хранящую текущее состояние
    LEX_STATES prev_state;    // Объявим переменную, хранящую предыдущее состояние
    char *lex_beg = text;     // Объявим и инициализируем указатель, хранящий начало обрабатываемой лексемы
    Lex cur_lex;              // Объявим переменную пользовательского типа для хранения текста лексемы и id
    int size = 0;             // Объявим и инициализируем переменную, хранящую текущую длинну лексемы
    do
    {
        prev_state = cur_state; // Предыдущее состояние=следующее состояние
        size = text - lex_beg;  // Размер лексемы как разница указателей
        if (size > 5)
            cur_state = E;                                         // Если размер лексемы >5, то переведём автомат в состояние ошибки
        cur_state = LEX_ST_MATRIX[GetNextState(*text)][cur_state]; // Переход по матрице состояний автомата
        // Далее блок кода с проверками и сохранением лексем, условие сложное...
        // Нам необходимо не сохранять читаемую лексему с ошибкой, пробелы, сохранять каждый новый знак сравнения и арифметические знаки по одному, сохранять знак '<>'.
        // Сохранять л-му будем при неравенстве prev & cur состояний, за искл. описанных случаев, и при одиночных знаках, переходящих в своё же состояние
        if ((cur_state != E && cur_state != I && prev_state != cur_state && prev_state != S) || prev_state == H || prev_state == D || prev_state == K || prev_state == C || (prev_state == J && cur_state != I))
        {
            cur_lex.str = new char[size + 1];    // Выделим память под динамический массив, хранящий текст лексемы
            strncpy(cur_lex.str, lex_beg, size); // Скопируем текст лексемы из исходного текста в динамический массив внутри cur_lex
            cur_lex.str[size] = '\0';            // Нультерминируем C-cтроку
            if (prev_state == B)                 // Проверка констант на диапазон значений
            {
                if (vec.size() && !strcmp(vec[vec.size() - 1].str, "-") && -32768 > atoi(cur_lex.str)) // Если предыдущая лексема--минус, то константа отрицательная (проверка на сущ. предыдущей лексемы)
                {
                    prev_state = E;
                }
                else if (atoi(cur_lex.str) > 32767) // Иначе--положительная
                {
                    prev_state = E;
                }
            }                        // Числа, не вход. в интервал--ошибка
            cur_lex.id = prev_state; // Так как id типов лексем совадают с индексами выходных состояний автомата, то сделаем так, так и было задумано, чтоб избежать, большого кол-ва сложных ф-й обработки
            if (cur_lex.id > 5)
                cur_lex.id = 6;
            if (prev_state == A)
                set_kw_id(cur_lex); // Если идентификатор совпал с ключевым словом, функция set_kw_id() изменит id нужного ключевого слова, или вернёт false
            vec.push_back(cur_lex); // Добавим новую лексему в конец std::vector<Lex>
            lex_beg = text;         // Передвинем указатель на начало лексемы
        }
        ++text; // Передвинем указатель на текущий символ на след символ
        if (cur_state == S)
            lex_beg = text;   // Чтоб начало не было до пробела
    } while (cur_state != F); // Выход по конечному состоянию автомата
}

// Объявляем перечисление с именем SINT_STATES, далее описан СИНТАКСИЧЕСКИЙ АНАЛИЗАТОР
// Описание состояний идёт подряд, все циклы описаны возвратом в предыдущее состояние
enum SINT_STATES
{
    S1, // Начальное состояние
    A1, // Прочитано do
    B1, // Прочитано until
    C1, // Прочитано not
    D1, // Прочитан операнд, возврат с бин. лог. опер. в B1
    G1, // Прочитан знак сравнения
    H1, // Прочитан второй операнд, возврат с бин. лог. опер. в B1
    I1, // Прочитан идентификатор, следующий подряд за операндом
    J1, // Прочитан знак равенства (присвоение)
    K1, // Прочитан операнд, возврат с ариф.опер в J1
    L1, // Прочитан знак ";", возврат с идентификатором в I1
    E1, // Состояние ошибки
    F1  // Состояние вывода синтаксически верной конструкции, прочитан loop, можно переидти с "do" в А1
};

// Матрица состояний и переходов конечного автомата
const enum SINT_STATES SINT_ST_MATRIX[12][13]{
    //      S1  A1  B1  C1  D1  G1  H1  I1  J1  K1  L1  E1  F1
    /*id*/ {E1, E1, D1, D1, I1, H1, I1, E1, K1, E1, I1, E1, E1},
    /*vl*/ {E1, E1, D1, D1, E1, H1, E1, E1, K1, E1, E1, E1, E1},
    /*ao*/ {E1, E1, E1, E1, E1, E1, E1, E1, E1, J1, E1, E1, E1},
    /*sc*/ {E1, E1, E1, E1, E1, E1, E1, E1, E1, L1, E1, E1, E1},
    /*wl*/ {E1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1},
    /*eq*/ {E1, E1, E1, E1, G1, E1, E1, J1, E1, E1, E1, E1, E1},
    /*co*/ {E1, E1, E1, E1, G1, E1, E1, E1, E1, E1, E1, E1, E1},
    /*do*/ {A1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1, A1},
    /*un*/ {E1, B1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1},
    /*lp*/ {E1, E1, E1, E1, E1, E1, E1, E1, E1, F1, E1, E1, E1},
    /*lo*/ {E1, E1, E1, E1, B1, E1, B1, E1, E1, E1, E1, E1, E1},
    /*no*/ {E1, E1, C1, E1, E1, E1, E1, E1, E1, E1, E1, E1, E1}};

void sint_analizer(vector<Lex> &vec)
{
    SINT_STATES cur_state = S1;                                          // Объявим и инициализируем переменную, хранящую текущее состояние
    long unsigned int i = 0;                                             // Объявим и инициализируем переменную--счётчик циклов
    while (i < vec.size() && SINT_ST_MATRIX[vec[i].id][cur_state] != E1) // Пока не последний элемент вектора или следующее состояние не ошибочно, обязательно условия в таком порядке, иначе обратимся к неинициализированной памяти
    {
        cur_state = SINT_ST_MATRIX[vec[i].id][cur_state]; // Переход по матрице состояний
        i++;                                              // Прибавим к счётчику единицу
    }
    Lex result;          // Лексема, хранящая результат синтаксического анализа, будет добавлена в конец вектора лексем для удобства вывода
    result.id = i;       // ID последней лексемы будет хранить порядковый номер лексемы, в которой произошла ошибка или "-1", если ошибок нет
    if (cur_state == F1) // Если текущее состояние F1 и считаны все лексемы значит имеем только верные конструкции
    {
        result.id = -1;
        result.str = new char[3];       // Выделем память под текст лексемы
        strncpy(result.str, "OK\0", 3); // Скопируем "OK\0"
        vec.push_back(result);          // Добавим лексему, хранящую результат в конец вектора
        return;                         // Выйдем из функции
    }
    // Если текущее состояние не F1 и считаны все лексемы значит имеем ошибку
    int out_size = 0;                          // Объявим и инициализируем переменную--счётчик длинны выходной строки
    for (int j = 0; j < 12; j++)               // В таблице состояний пробежимся по столбцу последнего состояния и посчитаем длинну выходной строки
        if (SINT_ST_MATRIX[j][cur_state] - 11) // Нас интересуют все состояния отличные от E1
            out_size += 3;                     // К счётчику длинны строки прибавим два символа и один пробел
    result.str = new char[out_size + 1];       // Выделем память под текст лексемы
    *result.str = '\0';                        // Необходимо для работы strcat(), нультерминируем строку в которую будем копировать
    for (int j = 0; j < 12; j++)               // В таблице состояний пробежимся по столбцу последнего состояния второй раз, чтобы выявить ID состояний, в которые можно было переидти
        if (SINT_ST_MATRIX[j][cur_state] - 11) // (кроме E1)
        {
            strcat(result.str, types[j]); // По выявленному ID скопируем конкатенацией строк в выходную строку наименование лексем, которые могли быть на месте ошибочной
            strcat(result.str, " \0");    // Ещё пробел скопируем
        }
    vec.push_back(result); // Добавим лексему, хранящую результат в конец вектора
}

int get_size(ifstream &fin) // Ф-я получения длинны файла
{
    fin.seekg(0, ios::end); // Указатель на конец файла
    int size = fin.tellg(); // Узнать позицию
    fin.seekg(0, ios::beg); // Передвинуть указатель на начало
    return size;            // Вернуть значение
}

ifstream &operator>>(ifstream &fin, char *&array) // Перегрузим оператор ввода
{
    int size = get_size(fin);           // Инициализируем целочисленную переменную конечной позицией в файле
    fin.getline(array, size + 1, '\0'); // Считаем файл с помощью метода getline
    return fin;                         // Вернём поток ввода
}

ostream &operator<<(ostream &fout, vector<Lex> &vec) // Перегрузим оператор вывода
{
    unsigned int i = 0;
    for (; i < vec.size() - 1; i++) // Перебор вектора до предпоследнего элемента, последний элемент--результат синтаксического анализа
    {
        fout << vec[i].str << '[' << types[vec[i].id] << ']' << ' '; // Вывод текста лексем и типа
    }
    fout << endl;        // Перевод на следующую строку для вывода результата синтаксического анализа
    if (vec[i].id == -1) // Если ID=-1, значит выведем только строку, хранящую "OK\0" (Так написана функция синтаксического анализатора)
    {
        fout << vec[i].str;
    }
    else // Иначе, выведем сначала ID, хранящий порядковый номер невеной лексемы,
    {    // затем строку, хранящую список ожидаемых лексем через одиночный пробел (Так написана функция синтаксического анализатора)
        fout << vec[i].id << ' ' << vec[i].str;
    }
    return fout; // Вернём поток
}

int main()
{
    ifstream fin("input.txt");   // Откроем файловый поток ввода
    ofstream fout("output.txt"); // Откроем файловый поток вывода
    if (!fin.is_open() && !fout.is_open())
        return 1; // Потоки не открылись--переидём к возвращению значений

    char *text = new char[get_size(fin) + 1]; // Создадим динамический массив типа char для хранения текста файла
    fin >> text;                              // С помощью перегрузки оператора ввода считаем текст из файла в массив
    fin.close();                              // Закроем поток ввода

    vector<Lex> vec;         // Объявим вектор лексем
    lex_analizer(text, vec); // Ф-я лексического анализатора
    delete[] text;           // Очистим место из-под динамического массива(удалим его)

    sint_analizer(vec); // Ф-я синтаксического анализатора

    fout << vec; // С помощью перегрузки оператора вывода выведем текст из std::vector<Lex> в файл
    cout << vec; // С помощью перегрузки оператора вывода выведем текст из std::vector<Lex> на экран

    for (unsigned int i = 0; i < vec.size(); i++) // Перебор вектора
    {
        delete[] vec[i].str; // Очистим задействованную память
    }

    fout.close(); // Закроем поток вывода
    return 0;     // Вернём 0
}
